-- Generated by Quartus II Version 9.0 (Build Build 132 02/25/2009)
-- Created on Sat Oct 02 20:19:30 2010

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.ALL;
USE ieee.std_logic_unsigned.ALL;
use ieee.NUMERIC_STD.all;

ENTITY test IS
	PORT
	(
		z 		: IN  STD_LOGIC_VECTOR(7 downto 0);			-- результат с испытуемого устройства
		rez	: out std_logic_vector(7 downto 0);			-- действительный результат
		x 		: in  STD_LOGIC_VECTOR(3  downto 0);		-- множимое
		y 		: in  STD_LOGIC_VECTOR(3  downto 0);		-- множитель
		mode 	: in  std_logic_vector(2  downto 0);		-- режим задает код, в котором представлены операнды,и формат чисел (целые/дробные)
		enable 	: out std_logic
	);
	
END test;
-- Режим устанавливается сигналом "Mode":

--		000   Прямой код, целые числа.
--		001   Прямой код, дробные числа.
--		010   Обратный код, целые числа.
--		011   Обратный код, дробные числа.
--		100   Дополнительный код, целые числа.
--		101   Дополнительный код, дробные числа.

architecture test_architecture of test is	

begin

process(x,y,z,mode)
-- этот процесс формирует действительный результат умножения, для заданных операндов и сравнивает его с полученным и формирует enable='1'
variable mkod : integer range 0 to 5;			-- код режима
variable zbin,mbin : std_logic_vector(7 downto 0);
variable xbin,ybin,xp,yp : std_logic_vector(3  downto 0);
-- хр,ур преобразованные множимое и множитель
begin


xbin:=x;		-- множимое
ybin:=y;		-- множитель
zbin:=z;		-- произведение,сформированное испытуемым устройством
mkod:=conv_integer(mode);	-- преобразуем код режима в целое в диапазоне от 0 до 5
if xbin(3)='1' then case mkod is	-- если множимое отрицательное, то
						 when 0|1 => xp:='0'& xbin(2 downto 0);	-- преобразум его в положительное (прямой код) 
						 when 2|3 => xp:=not xbin(3 downto 0);		-- преобразум его в положительное (обратный код)
						 when 4|5 => xp:=not xbin(3 downto 0)+1;	-- преобразум его в положительное (дополнительный код)
				   	 end case;
	else xp:=xbin; end if;												-- иначе, не меняем множимое

if ybin(3)='1' then case mkod is -- аналогичным образом преобразум множитель, если он отрицательный
						 when 0|1 => yp:='0'& ybin(2 downto 0);	-- преобразум его в положительный (прямой код) 
					 	 when 2|3 => yp:=not ybin(3 downto 0);		-- преобразум его в положительный (обратный код)
						 when 4|5 => yp:=not ybin(3 downto 0)+1;	-- преобразум его в положительный (дополнительный код)
					end case;
	else yp:=ybin; end if;												-- иначе, не меняем множитель

mbin:=xp*yp;			-- вычисляем произведение для положительных операндов
if (ybin(3) xor xbin(3))='1' then case mkod is			-- если результат отрицательный, представляем его в коде
									   when 0 => mbin(7):='1'; -- в знаковый разряд записываем '1', если прямой код и целые числа
									   when 1 => mbin:='1'& mbin(5 downto 0)&'0';					--, если прямой код и дробные числа
									   when 2 => mbin:=not mbin; mbin(7):='1';						--, если обратный код и целые числа
									   when 3 => mbin:=not mbin; mbin:='1'& mbin(5 downto 0)&'1';--,если обратный код и дробные числа 									   
									   when 4 => if mbin/="00000000" then 								--, если дополнительный код и целые числа
												 mbin:=not mbin+1; mbin(7):='1'; end if;
									   when 5 => if mbin/="00000000" then								--, если дополнительный код и дробные числа
												 mbin:=not mbin+1; mbin:='1'& mbin(5 downto 0)&'0'; end if;
								   end case;
else case mkod is				-- если результат положительный
		  when 0|2|4 => null;-- если числа целые
		  when 1|3|5 => mbin(6 downto 0):=mbin(5 downto 0)&'0';-- если числа дробные
	  end case;
end if;

zbin:=z;		---- произведение,сформированное испытуемым устройством 
rez <= mbin;	--передаем на выход действительный результат
if zbin/=mbin then report "������ � �����������" severity warning; enable <= '0'; -- если не совпадает
else enable <= '1'; end if;

if xbin="1111" and ybin="1111" then report "���� ������� �� �����" severity warning;
enable <= '0'; end if;

end process;

END test_architecture;
